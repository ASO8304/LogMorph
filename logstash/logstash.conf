# ===========================
# Input Section: Receive logs via UDP
# ===========================
input {
  udp {
    port => 5140                          # Listen on UDP port 5140
    codec => plain { charset => "UTF-8" } # Decode incoming messages as plain UTF-8 text
  }
}

# ===========================
# Filter Section: Parse and enrich logs
# ===========================
filter {
  # ---- Use Grok to parse log message formats ----
  grok {
    match => {
      "message" => [
        # Format #1:
        # Single MAC block followed by direction, IPs, ports, and rest of the message
        "^%{NUMBER}\s+%{NUMBER}\s+\[%{WORD:in_mac} %{WORD:out_mac}\]\s+%{WORD}\s+%{WORD:dir}\s+%{NUMBER:len}\s+%{NUMBER:proto}\s+%{IP:src_ip}\s+%{IP:dst_ip}\s+DF\s+0\s+%{NUMBER:src_port}\s+%{NUMBER:dst_port}\s+%{GREEDYDATA:rest1}",

        # Format #2:
        # Two MAC blocks and extended protocol info (possibly encapsulated packets)
        "^%{NUMBER}\s+%{NUMBER}\s+\[%{WORD:in_mac} %{WORD:out_mac}\]\s+%{WORD}\s+%{WORD:dir}\s+%{NUMBER:len}\s+%{NUMBER:proto}\s+%{IP:src_ip}\s+%{IP:dst_ip}\s+DF\s+0\s+%{NUMBER:src_port}\s+%{NUMBER:dst_port}\s+%{GREEDYDATA:rest1}\s+\[%{WORD:in_mac2} %{WORD:out_mac2}\]\s+%{NUMBER:length2}\s+%{NUMBER:protocol2}\s+%{IP:src_ip2}\s+%{IP:dst_ip2}\s+%{GREEDYDATA:rest2}"
      ]
    }
    tag_on_failure => ["_grok_fail"]      # Add failure tag if Grok fails
  }

  # ---- Flag Grok result ----
  if "_grok_fail" not in [tags] {
    mutate { add_field => { "log_stage" => "grok_ok" } }  # Mark success
  } else {
    mutate { add_field => { "log_stage" => "grok_fail" } }  # Mark failure
  }

  # ---- Merge remaining message parts into a single description field ----
  ruby {
    code => '
      r1 = event.get("rest1") || ""
      r2 = event.get("rest2") || ""
      description = "#{r1} #{r2}".strip
      event.set("description", description)
    '
  }

  mutate {
    remove_field => ["rest1", "rest2"]  # Cleanup unused fields
  }
}

# ===========================
# Output Section: Send processed logs to destination
# ===========================
output {
  # ---- Send log batch as JSON to FastAPI endpoint ----
  http {
    url          => "http://127.0.0.1:10000/logs"  # FastAPI backend receiver
    http_method  => "post"
    format       => "json_batch"                   # Send all events in a single JSON array
    content_type => "application/json"
    retry_failed => false                          # Do not retry failed sends
  }

  # ---- Debug output to console ----
  stdout {
    codec => rubydebug  # Pretty-print log for debugging
  }
}

# ===========================
# Grok Format Reference
# ===========================
# Format #1: Basic format with one MAC block
#   Example:
#     123 456 [aa:bb:cc:dd:ee:ff 11:22:33:44:55:66] ether in 128 6 192.168.1.1 192.168.1.2 DF 0 12345 80 payload info
#
# Format #2: Extended format with two MAC blocks (encapsulated packet?)
#   Example:
#     123 456 [aa:bb:cc:dd:ee:ff 11:22:33:44:55:66] ether out 128 6 192.168.1.1 192.168.1.2 DF 0 12345 80 details [66:77:88:99:aa:bb cc:dd:ee:ff:00:11] 256 17 10.0.0.1 10.0.0.2 encapsulated details
#
# Grok Fields Extracted:
#   - in_mac, out_mac:       Source and destination MAC addresses
#   - dir:                   Direction ("in", "out")
#   - len:                   Packet length
#   - proto:                 Protocol number (6=TCP, 17=UDP)
#   - src_ip, dst_ip:        Source and destination IP addresses
#   - src_port, dst_port:    Port numbers
#   - description:           Combined rest of message (for context/metadata)

# Make sure the FastAPI service is running on port 10000 before starting Logstash.
