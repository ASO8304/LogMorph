input {
  udp {
    port => 5140
    codec => plain { charset => "UTF-8" }
  }
}

filter {
  grok {
    match => {
      "message" => [
        # Format #1: count+seq, single MAC, trailing rest1
        "^%{NUMBER}\s+%{NUMBER}\s+\[%{WORD:in_mac} %{WORD:out_mac}\]\s+%{WORD}\s+%{WORD:dir}\s+%{NUMBER:len}\s+%{NUMBER:proto}\s+%{IP:src_ip}\s+%{IP:dst_ip}\s+DF\s+0\s+%{NUMBER:src_port}\s+%{NUMBER:dst_port}\s+%{GREEDYDATA:rest1}",

        # Format #2: count+seq, two MAC blocks, rest1/rest2
        "^%{NUMBER}\s+%{NUMBER}\s+\[%{WORD:in_mac} %{WORD:out_mac}\]\s+%{WORD}\s+%{WORD:dir}\s+%{NUMBER:len}\s+%{NUMBER:proto}\s+%{IP:src_ip}\s+%{IP:dst_ip}\s+DF\s+0\s+%{NUMBER:src_port}\s+%{NUMBER:dst_port}\s+%{GREEDYDATA:rest1}\s+\[%{WORD:in_mac2} %{WORD:out_mac2}\]\s+%{NUMBER:length2}\s+%{NUMBER:protocol2}\s+%{IP:src_ip2}\s+%{IP:dst_ip2}\s+%{GREEDYDATA:rest2}"
      ]
    }
    tag_on_failure => ["_grok_fail"]
  }

  # Indicate Grok success or failure
  if "_grok_fail" not in [tags] {
    mutate { add_field => { "log_stage" => "grok_ok" } }
  } else {
    mutate { add_field => { "log_stage" => "grok_fail" } }
  }

  # Build flat description from rest1 + rest2
  ruby {
    code => '
      r1 = event.get("rest1") || ""
      r2 = event.get("rest2") || ""
      description = "#{r1} #{r2}".strip
      event.set("description", description)
    '
  }

  mutate {
    remove_field => ["rest1", "rest2"]
  }
  
}

output {
  http {
    url          => "http://127.0.0.1:10000/logs"
    http_method  => "post"
    format       => "json_batch"
    content_type => "application/json"
    retry_failed => false
  }

  stdout {
    codec => rubydebug
  }
}